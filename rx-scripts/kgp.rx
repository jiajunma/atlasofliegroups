<orbits.rx {for sort_u}

{K orbits on G/P
P is a set of simple roots
P -> partial order on KGB, generated by ascents not in P
  -> equivalence relation generated by this 
KGB/equivalence <-> K\G/P
Define KGP to be the set of equivalence classes
Write KGP=[y_1,...,y_r] where each y_i is an equivalence class (a subset of KGB)
The last element y_i is maximal, uniquely determined
y_i is closed if and only if the first element in it is closed in KGB
}

{complement of subset of simple roots in rank n}
set complement(int n,[int] P)=[int]:
let rv=for i:n do i od in for j in reverse_sort(P) do  rv:=delete(rv,j) od;rv

{add i to list if (and only if) it is new}
set add_new(int i,[int] list)=[int]: if find(i,list)=-1 then list#i else list fi 

set number(KGBElt x)=let (,n)=%x in n

set sort_by((KGBElt -> int) f)= ([KGBElt] v) [KGBElt]:
  for index in inv_standardisation(for x in v do f(x) od) do v[index] od
set sort=([KGBElt] -> [KGBElt]):sort_by((KGBElt x) int: number(x))
set min([KGBElt] y)=sort(y)[0]
set max([KGBElt] y)=sort(y)[#sort(y)-1]

{elements above x one step in the partial order given by ascents in P}
set up_neighbors(KGBElt x,[int] P)=[int]:
let rv=[int]:[] in
for i in P do
 let t=status(i,x) in 
  if t=3 then rv#:=number(Cayley(i,x))
  elif t=4 then rv#:=number(cross(i,x)) fi od;sort_u(rv)

{elements below x one step in the partial order}
set down_neighbors(KGBElt x,[int] P)=[int]:
let rv=[int]:[] in
for i in P do
 let t=status(i,x) in 
  if t=2 then 
   let y=Cayley(i,x) in 
    rv#:=number(y); rv#:=number(cross(i,y)) 
  elif t=0 then rv#:=number(cross(i,x)) fi od;sort_u(rv)

{maximal elements in the partial order}
set maximal_in_partial_order(RealForm G,[int] P)=[KGBElt]:
let rv=[int]:[] in for x in KGB(G) do if #up_neighbors(x,P)=0 then rv#:=number(x) fi od;
for i in sort(rv) do KGB(G,i) od

{equivalence class of maximal element in partial order, this is an element of KGP}
set equivalence_class_of(KGBElt x_max, [int] P)=[KGBElt]:
let G=real_form(x_max),rv=[number(x_max)], to_do=[number(x_max)] in 
while #to_do>0 do
 let y=KGB(G,to_do[0]) then
 new=down_neighbors(y,P) in
 for i in new do rv:=add_new(i,rv);to_do:=add_new(i,to_do) od;
 to_do:=delete(to_do,0) od;for i in sort(rv) do KGB(G,i) od 

set KGP(RealForm G,[int] P)=[[KGBElt]]:
for x in maximal_in_partial_order(G,P) do equivalence_class_of(x,P) od

{sometimes convenient to just keep the numbers, although this loses the information of what G is}
set KGP_numbers(RealForm G,[int] P) =[[int]]:let ec=KGP(G,P) in for c in ec do for x in c do number(x) od od

{test if y\in K\G/P is closed: <=> length(first element)=0}
set is_closed([KGBElt] y,[int] P)=bool:length(min(y))=0

{test if y\in K\G/P is theta-stable: <=> closed and 
alpha simple, not in P => alpha is imaginary C+ for max(y)
}
set is_theta_stable([KGBElt] y,[int] P)=bool:
let x=max(y) in 
is_closed(y,P) and
all( for j in complement(semisimple_rank(real_form(x)),P) do
 let s=status(j,x) in s=1 or s=3 or s=4 od ) 

set theta_stable_parabolics(RealForm G,[int] P)=
let rv=[KGBElt]:[] in  for y in KGP(G,P) do if is_theta_stable(y,P) then rv#:=max(y) fi od;rv

{list of parabolics: [([int] P,[int] x)] where for each P, each x is the maximal 
element of an element of KGP
}
set all_theta_stable_parabolics(RealForm G)=[([int],[KGBElt])]:
let n=semisimple_rank(G) then
all=generate_all_subsets(for i:n do i od) then
rv=[]  in
for P in all do (P,theta_stable_parabolics(G,P)) od
{ let rv_P=[KGBElt]:[] in  for y in KGP(G,P) do if is_theta_stable(y,P) then rv_P#:=max(y) fi od;rv#:=(P,rv_P) od;rv}

set Levi([int] P,KGBElt x)=real_form(Levi(real_form(x),P),involution(x),torus_factor(x))

set print_all_theta_stable_parabolics(RealForm G)=void:
let total=0 in for (P,v) in all_theta_stable_parabolics(G) do
let L=Levi(G,P) in 
prints();
prints("P:",P);
prints("Complex Levi: ", L);
total+:=#v;
prints("x: ",for x in v do number(x) od, " (",#v,")");
prints("Real forms: ");
for x in v do prints(number(x), ": ",real_form(L,involution(x),torus_factor(x))) od
od;prints("Total: ",total) 









