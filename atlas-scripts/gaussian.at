<basic.at
{ Gaussian elimination on matrices represented by values of type [[rat]] }

{ matrices by lists of lists of rational numbers, forming their columns }

set pivot_step (([(int,rat)]->int) choose_pivot) =
    ([[rat]] M, int i) (int,[rat],[[rat]]):
    (  let col=M[0]
       then k = i + choose_pivot(for e@d in col[i:] do (d,e) od), n=#col
       then src = { list for each |r| from which index new row |r| is taken }
          for r:n do if r<i or r>k then r elif r=i then k else r-1 fi od
       , f = col[k] { value of the pivot entry }
       then coefs = for r:n do if r=i then /f else -col[src[r]]/f fi od
       in (k,coefs
          , for c@j in M[1:]
            do let ck=c[k] in
               for r:n do if r=i then ck/f else c[src[r]]+ck*coefs[r] fi od
            od
          )
    )

set greedy ([(int,rat)] choices) = int:
    let i = for (,r) in choices do r!=0 od.first then (k,)=choices[i] in k

set step = pivot_step(greedy@[(int,rat)])

set get_data ([[rat]] M) = [(int,[rat])]:
    let i=-1 in
    while >#M do let (pivot,coefs,M0)=step(M,i+:=1) in M:=M0;(pivot,coefs) od

set apply (int i, int k, [rat] coefs) = ([rat]->[rat]):
    let n=#coefs
    then src = { list for each |r| from which index new row |r| is taken }
          for r:n do if r<i or r>k then r elif r=i then k else r-1 fi od
    in ([rat] c) [rat]:
       for r:n do let a=c[k]*coefs[r] in if r=i then a else c[src[r]]+a fi od

set make_inverse ([(int,[rat])] data) = [[rat]]:
    for c in id_mat(#data)
    do let c=[rat]: for e in c do e od { convert to [rat] } in
       for (pivot,coefs)@j in data do c:=apply(j,pivot,coefs)(c) od
    ;  c
    od

set inverse ([[rat]] M) = [[rat]]: M.get_data.make_inverse

{ now do the same with |ratvec| for columns of a matrix }

set do_pivot (([(int,rat)]->int) choose_pivot) =
    ([ratvec] M, int i) (int,ratvec,[ratvec]):
    (  let col=M[0]
       then k = i + choose_pivot(for e@d in col[i:] do (d,e) od), n=#col
       then src = { list for each |r| from which index new row |r| is taken }
          for r:n do if r<i or r>k then r elif r=i then k else r-1 fi od
       , f = col[k] { value of the pivot entry }
       then coefs = for r:n do if r=i then /f else -col[src[r]]/f fi od
       in (k,coefs
          , for c@j in M[1:] { do row operations on remaining columns }
            do for cfr@r in coefs
               do let a=c[k]*cfr in if r=i then a else c[src[r]]+a fi
	      od
            od
          )
    )

set do_step = do_pivot(greedy@[(int,rat)])

set Gaussian_invert ([ratvec] A) = [ratvec]:
    let data =
       let i=-1 in while >#A do let (p,c,M)=do_step(A,i+:=1) in A:=M; (p,c) od
    then n=#data
    in
    for j:n
    do let c = ratvec: for i:n do #(i=j) od { column of identity matrix } in
       for (pivot,coefs)@i in data
       do c:= { apply rot operations from |pivot,coefs) to |c| }
          if pivot=i { frequent case of pivot on main diagonal }
          then
             for cfr@r in coefs
             do let a=c[pivot]*cfr in if r=i then a else c[r]+a fi od
          else
             let src =
                for r:n
	       do if r<i or r>pivot then r elif r=i then pivot else r-1 fi
	       od
             in for cfr@r in coefs
                do let a=c[pivot]*cfr in if r=i then a else c[src[r]]+a fi
	       od
          fi
       od
    ;  c
    od

set times ([[rat]] M, [rat] v) = [rat]:
    for i:#M[0] do let s=rat:0 in for Mj@j in M do s+:=Mj[i]*v[j] od; s od

set times ([[rat]] M, [[rat]] N) = [[rat]]: for c in N do times(M,c) od

